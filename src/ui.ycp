/* ------------------------------------------------------------------------------
 * Copyright (c) 2006-2012 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	include/rear/ui.ycp
 * Package:	Configuration of rear
 * Summary:	Dialogs definitions
 * Authors:	Thomas Goettlicher <tgoettlicher@suse.de>
 *
 * $Id$
 */

{

textdomain "rear";

import "Rear";
import "RearSystemCheck";
import "Label";
import "Message";
import "Package";
import "Popup";
import "Service";
import "Wizard";
import "Storage";
import "Progress";


define list<string> AvailableModules()
{
   string cmd = "lsmod | tail +2 | cut -d ' ' -f1 | tac | tr -s '[:space:]' ' '";
   map output = (map) SCR::Execute (.target.bash_output, cmd, "");
   list <string> ret = splitstring (output["stdout"]:"", " ");
   return ret;
}


define list<term> UsbTerms( )
{
    return maplist(string name, string text, Rear::GetUsbPartitions(),
    {
        return `item(`id(name), text) ;
    });
}

/**
 * Dialog to Choose Directories
 */
define list<string> DirectoriesDialog(list <string> directories)
{
    list <string> directories_sav = directories;

    UI::OpenDialog(
                  `VBox(
                  `SelectionBox( `id(`dirs), _("Additional Directories to Backup"), directories ),
                  `HBox(
                    `PushButton( `id(`adddir), Label::AddButton() ),
                    `HSpacing(4),
                    `PushButton( `id(`deldir), Label::DeleteButton() )
                  ),

                  `HBox(
                      `PushButton(`id(`ok    ), _( "&OK"     ) ),
                      `PushButton(`id(`cancel), _( "&Cancel" ) )
                  )

              ));

    symbol ret=nil;
    do
    {
        if ( ret == `deldir )
        {
             string delelem = (string)UI::QueryWidget( `id(`dirs), `CurrentItem);
             directories = filter (string elem, directories, { return (elem != delelem ); });
             UI::ChangeWidget( `id(`dirs), `Items, directories);
        }
        if ( ret == `adddir )
        {
             string addelem = UI::AskForExistingDirectory ( "/", _("Choose Directory"));
             if ( ! contains(directories,addelem) )
             {
                  directories = add(directories, addelem);
                  UI::ChangeWidget( `id(`dirs), `Items, directories);
             }
        }
        ret = (symbol) UI::UserInput();

    }
    while (ret != `ok && ret != `cancel );
 
    UI::CloseDialog();

    if ( ret == `cancel )
            return directories_sav; 

    return directories;
}

define boolean SaveConfig ( list<string> modules_load, list<string> backup_prog_include )
{
    Rear::modified		= true;
    Rear::output		= (string) UI::QueryWidget(`id(`output), `Value );
    Rear::netfs_url		= (string) UI::QueryWidget(`id(`netfs_url), `Value );
    Rear::netfs_keep_old_backup = (boolean) UI::QueryWidget(`id(`netfs_keep_old_backup), `Value );
    Rear::modules_load          = modules_load;
    Rear::backup_prog_include   = backup_prog_include;

    return true;
}


/**
 * Dialog to Choose Kernel Modules
 */
define list<string> KernelModulesDialog(list <string> modules)
{
    list <string> modules_sav = modules;
    list <string> all_modules = AvailableModules();
 
    UI::OpenDialog(
                  `VBox( 
                  `SelectionBox( `id(`mods), _("Additional Kernel Modules for Rescue System"), modules ),
                  `HBox(
                    `MinWidth(15, `ComboBox( `id(`newmod), `opt(`editable), "", all_modules ) ),
                    `PushButton( `id(`addmod), Label::AddButton() ),
                    `HSpacing(4),
                    `PushButton( `id(`delmod), Label::DeleteButton() )
                  ),

                  `HBox(
                      `PushButton(`id(`ok    ), _( "&OK"     ) ),
                      `PushButton(`id(`cancel), _( "&Cancel" ) )
                  )

              ));

    symbol ret=nil;
    do
    {
        if ( ret == `delmod )
        {
             string delelem = (string)UI::QueryWidget( `id(`mods), `CurrentItem);
             modules = filter (string elem, modules, { return (elem != delelem ); });
             UI::ChangeWidget( `id(`mods), `Items, modules);
        }
        if ( ret == `addmod )
        {
             string addelem = (string)UI::QueryWidget( `id(`newmod), `Value);
             if ( ! contains(modules,addelem) )
             {
                  modules = add(modules, addelem);
                  UI::ChangeWidget( `id(`mods), `Items, modules);
             }
        }
        ret = (symbol) UI::UserInput();

    }
    while (ret != `ok && ret != `cancel );
 
    UI::CloseDialog();

    if ( ret == `cancel )
            return modules_sav; 

    return modules;
}



/**
 * Dialog to run rear
 */
define symbol RearRunDialog () {

    UI::OpenDialog(`opt(`decorated),
    `HBox(`HSpacing(1.5), `VSpacing(18),
    `VBox(
        `HSpacing(80),
        `VSpacing(0.5),
        `LogView (`id (`log), "Rear output:", 8, 0),
        `PushButton (`id(`close), Label::CloseButton ()),
        `VSpacing(0.5)),
    `HSpacing(1.5)
    ));

    UI::ChangeWidget (`id(`close), `Enabled, false);

    string output  = "";
    SCR::Execute (.background.run_output, "bash -c \"/usr/sbin/rear mkbackup; sleep 1\"");

    symbol ret = nil;
    do
    {
        ret = (symbol) UI::PollInput();

        if ((boolean) SCR::Read(.background.output_open) &&
            (integer) SCR::Read(.background.newlines)>0)
        {
            // read the output line from rear:
            list out    = (list)SCR::Read(.background.newout);
            output = out[0]:"";
            if (output != "")
                UI::ChangeWidget (`id(`log), `LastLine, output + "\n");
        }
        else if (!(boolean)SCR::Read(.background.output_open))
        {
            UI::ChangeWidget (`id(`close), `Enabled, true);
            ret = (symbol) UI::UserInput();
        }
        sleep (100);
    } while (ret != `close ); 

    SCR::Execute(.background.kill);
    UI::CloseDialog();
    return ret;
}





/**
 * Dialog for setup up Rear
 */
define symbol RearConfigDialog () {

    // For translators: Caption of the dialog
    string caption = _("Rear Configuration");

    // help text for Rear 
    string help = _("<p>Here, configure Rear Relax and Recover backup for your computer.</p>") +
    _("<p>.</p>");

    list <string> netfs_url = [ Rear::netfs_url ];
    boolean netfs_keep_old_backup = Rear::netfs_keep_old_backup;
    list<string> modules_load = Rear::modules_load;
    list<string> backup_prog_include = Rear::backup_prog_include;
    string output = Rear::output;
    list<string> outputlist = ["ISO", "USB"];
    list<term> usbpartitions = UsbTerms();
    list<string> nfslocation = ["nfs://hostname/directory"];

    list backup_type = ["NFS", "USB"];

    list<term> expertMenu = [ `item(`id(`additionalDirs), _("Additional Directories in Backup" )) ,
                              `item(`id(`additionalModules), _("Additional Kernel Modules in Rescue System" )),
                              `item(`id(`scanusb), _("Rescan USB Devices")) ];

    term con = `HBox (`HSpacing (3), `VBox (
        `VSpacing (),
	`Frame (_("Recovery System"), `HBox (`HSpacing (),
	    `VBox (
		`VSpacing (0.5),
		`ComboBox (`id(`output), `opt(`notify, `hstretch), _("&Boot Media"), outputlist),
		`VSpacing (0.5)
	    ), `HSpacing ()
	)),
	`VSpacing (1.5),
	`Frame (_("Backup"), `HBox (`HSpacing (),
	    `VBox (
		`VSpacing (0.5),
		`ComboBox (`id(`backup_type), `opt(`notify, `hstretch), _("&Backup Media"), backup_type),
		`VSpacing (0.5),
                `ReplacePoint(`id(`rp), `ComboBox (`id(`netfs_url), `opt(`notify, `hstretch, `editable), _("&Location"), netfs_url)),
		`VSpacing (0.5),
		`CheckBox (`id(`netfs_keep_old_backup), `opt(`notify), _("&Keep old backup"), netfs_keep_old_backup),
		`VSpacing (0.5)
	    ), `HSpacing ()
	)),
	`VSpacing (0.5),
        `Right( `MenuButton( _("Advanced"), expertMenu )),
	`VSpacing (0.5),
        `PushButton(`id(`runrear    ), _( "Save and Run") ),
	`VStretch ()
    ), `HSpacing(3));


    Wizard::SetContents (caption, con, help, true, true);


    /* If config file was manually edited and config options are unknown we show a warning */
    boolean config_conflicts = false;

    if (contains(add(outputlist,""), output))
        UI::ChangeWidget (`id(`output), `Value, output);
    else
        config_conflicts = true;

    string type = toupper(substring(Rear::netfs_url,0,3));
    if (contains(add(backup_type,""), type))
    {
        UI::ChangeWidget (`id(`backup_type), `Value, type);
        if ( type == "NFS" )
        {
           if ( ! contains (nfslocation, Rear::netfs_url) )
              nfslocation = prepend (nfslocation, Rear::netfs_url);
           UI::ChangeWidget (`id(`netfs_url), `Items, nfslocation );
        }
    }
    else
        config_conflicts = true;

    if ( Rear::backup != "NETFS" && Rear::backup !=  "" )
        config_conflicts = true;


    if (config_conflicts &&
        ! Popup::ContinueCancel ( _("Your rear configuration file contains options this YaST2 module cannot configure.\n"
                                  "Do you want to continue and overwrite these settings?" )))
        return `abort;


    // this flag ensures that the combox is correctly refilled
    // when the USB/NFS combobox is changed
    boolean rebuild_combobox_flag = false;

    symbol ret = nil;
    do
    {
        if ( UI::QueryWidget(`id(`backup_type), `Value ) == "USB" && rebuild_combobox_flag==false)
        {
           UI::ReplaceWidget(`id(`rp), `ComboBox (`id(`netfs_url), `opt(`notify, `hstretch), _("&Location"), usbpartitions));
           rebuild_combobox_flag=true;
        }

        if ( (string) UI::QueryWidget(`id(`backup_type), `Value ) == "NFS" && rebuild_combobox_flag==true )
        {
           UI::ReplaceWidget(`id(`rp), `ComboBox (`id(`netfs_url), `opt(`notify, `hstretch, `editable), _("&Location"), nfslocation));
           rebuild_combobox_flag=false;
        }

        if ( ret == `runrear)
        {
	   if ( "USB" != (string) UI::QueryWidget(`id(`output), `Value ) || 
                Popup::ContinueCancel ("Your USB media will be overwritten. To you want to continue?" ))
           {
               SaveConfig(modules_load, backup_prog_include);
               Rear::Write ();
	       RearRunDialog();
           }
        }

        if (ret == `scanusb )
        {
           usbpartitions=UsbTerms();
           if ( UI::QueryWidget(`id(`backup_type), `Value ) == "USB" )
               UI::ChangeWidget (`id(`netfs_url), `Items, usbpartitions );
        }

        if ( ret == `additionalModules)
            modules_load = KernelModulesDialog(modules_load);

        if ( ret == `additionalDirs)
            backup_prog_include = DirectoriesDialog(backup_prog_include);


	ret = (symbol) UI::UserInput ();

    } while (!contains ([`back, `abort, `cancel, `next, `ok], ret));

    if (ret == `next || ret == `ok)
        SaveConfig(modules_load, backup_prog_include);

    return ret;
}


/**
 * The whole sequence
 */
define symbol RearSequence () {

    Wizard::OpenOKDialog ();
    Wizard::SetDesktopTitleAndIcon("rear");

    /* Rear read dialog caption */
    string caption      = _("Reading Rear Configuration");
    integer steps       = 2;

    Progress::New (caption, " ", steps, [
            _("Analyzing system"),
            _("Reading rear settings"),
        ], [
            _("Analyzing system..."),
            _("Reading rear settings..."),
            _("Finished")
        ],
        ""
    );

    Progress::NextStage();

    string system_check_message = RearSystemCheck::SystemCheck();

    if ( system_check_message != nil &&
        ! Popup::ContinueCancel ( _("This system is not supported.") +"\n" +system_check_message +"\n"+
                                  _("Do you want to continue anyways?" )))
        return `abort;

    Progress::NextStage();

    Rear::Read ();

    Progress::NextStage();

    symbol ret = RearConfigDialog ();
    if ( ret == `next || ret == `ok )
        Rear::Write ();

    UI::CloseDialog ();
    return ret;
}

}
