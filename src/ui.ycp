/* ------------------------------------------------------------------------------
 * Copyright (c) 2012 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	include/rear/ui.ycp
 * Package:	Configuration of rear
 * Summary:	Dialogs definitions
 * Authors:	Thomas Goettlicher <tgoettlicher@suse.de>
 *
 * $Id$
 */

{

textdomain "rear";

import "Rear";
import "RearSystemCheck";
import "Label";
import "Message";
import "Package";
import "Popup";
import "Service";
import "Wizard";
import "Storage";
import "Progress";
import "Confirm";
import "Package";
import "Report";

/**
 * returns currently loaded kernel modules
 */
list<term> UsedModules()
{
    list<term> modules = [];

    string cmd = "lsmod | tail +2 | cut -d ' ' -f1 | tac | tr -s '[:space:]' ' '";
    map output = (map) SCR::Execute (.target.bash_output, cmd, "");
    list <string> mods = splitstring (output["stdout"]:"", " ");

    integer n=1;
    foreach ( string mod, mods,
    {
	if ( mod != "" )
       //     modules = add(modules, `item(`id(mod), sformat("%1. %2",n,mod ))); n=n+1;
            modules = add(modules, `item(`id(mod), sformat("%1",mod ))); n=n+1;
    } );
    return modules;
}

/*
 * returns availible partitions on usb media
 */
list<term> UsbPartitions( )
{
    return maplist(string name, string text, Rear::GetUsbPartitions(),
    {
        return `item(`id(name), text) ;
    });
}

/**
 * Dialog shown, when system is not supported by rear
 */
symbol UnsupportedDialog(list <string> messages)
{
    string message =  _("This system is not supported by rear, because:") +
	              "<ul><li>" + mergestring(messages,"</li><li>") + "</li></ul><strong>" +
                      _("Do NOT expect the created backup to be useful for system recovery if you ignore this warning.") +
                      "</strong>";

    UI::OpenDialog(`opt(`decorated),
    `HBox(`HSpacing(1.5), 
    `VBox(
        `HSpacing(50),
        `VSpacing(0.5),
        `Label(_("This system is not supported.")),
        `VSpacing(0.5),
        `VBox(`RichText(message)),
        `ButtonBox(
             `PushButton(`id(`ok    ), _( "&Ignore and continue" ) ),
             `PushButton(`id(`cancel), _( "&Cancel" ) )
             ),
        `VSpacing(0.5)),
    `HSpacing(1.5)
    ));

    symbol ret=nil;
    do {
	ret = (symbol) UI::UserInput();
    }
    while (ret != `ok && ret != `cancel );

    UI::CloseDialog();
    return ret;
}

/**
 * Dialog to Choose Directories
 */
list<string> DirectoriesDialog(list <string> directories)
{
    // store original value of directories for the case that the users clicks cancel
    list <string> directories_sav = directories;

    UI::OpenDialog(
                  `MinSize( 45, 15,
                   `HBox(
                    `HSpacing(1),
                    `VBox(
                     `VSpacing(0.5),
                     `VBox(
                      `SelectionBox( `id(`dirs), _("Additional Directories to Backup"), directories ),
                      `HBox(
                       `PushButton( `id(`adddir), Label::AddButton() ),
                       `HSpacing(4),
                       `PushButton( `id(`deldir), Label::DeleteButton() )
                      ),
                      `ButtonBox(
                       `PushButton(`id(`ok    ), _( "&OK"     ) ),
                       `PushButton(`id(`cancel), _( "&Cancel" ) )
                      )
                    ),
                    `VSpacing(0.5)
                   ),
                  `HSpacing(1)
                  )
                 )
                );

    symbol ret=nil;
    do
    {
        if ( ret == `deldir )
        {
             string delelem = (string)UI::QueryWidget( `id(`dirs), `CurrentItem);
             directories = filter (string elem, directories, { return (elem != delelem ); });
             UI::ChangeWidget( `id(`dirs), `Items, directories);
        }
        if ( ret == `adddir )
        {
             string addelem = UI::AskForExistingDirectory ( "/", _("Choose Directory"));
             if ( ! contains(directories,addelem) )
             {
                  directories = add(directories, addelem);
                  UI::ChangeWidget( `id(`dirs), `Items, directories);
             }
        }
        ret = (symbol) UI::UserInput();

    }
    while (ret != `ok && ret != `cancel );
 
    UI::CloseDialog();

    if ( ret == `cancel )
            return directories_sav; 

    return directories;
}

boolean SaveConfig ( list<string> modules_load, list<string> backup_prog_include )
{
    Rear::modified		= true;
    Rear::output		= (string) UI::QueryWidget(`id(`output), `Value );
    Rear::netfs_url		= (string) UI::QueryWidget(`id(`netfs_url), `Value );
    Rear::netfs_keep_old_backup = (boolean) UI::QueryWidget(`id(`netfs_keep_old_backup), `Value );
    Rear::modules_load          = modules_load;
    Rear::backup_prog_include   = backup_prog_include;
    if (! Rear::Write () )
    {
	Popup::Error(_("Cannot write rear configuration file."));
        return false;
    }

    return true;
}


/**
 * Dialog to Choose Kernel Modules
 */
list<string> KernelModulesDialog(list <string> modules)
{
    // store original value of modules for the case that the users clicks cancel
    list <string> modules_sav = modules;

    UI::OpenDialog(
                  `MinSize( 50, 20,


                   `HBox(
                    `HSpacing(1),
                     `VBox(
                      `VSpacing(0.5),
                      `Label(`opt(`boldFont),_("Additional Kernel Modules")),
                      `VSpacing(0.5),
                      `HBox(
                       `MinWidth( 30,
                       `SelectionBox( `id(`availablemods), _("Available Modules in current System:"), UsedModules() ) ),
                       `VBox(
                        `VStretch(),
                        `PushButton( `id(`delmod), Label::DeleteButton() ),
                        `PushButton( `id(`addmod), UI::Glyph(`ArrowRight) ),
                        `VStretch(),
                        `PushButton( `id(`up), UI::Glyph(`ArrowUp) ),
                        `PushButton( `id(`down), UI::Glyph(`ArrowDown) ) ,
                        `VStretch()
                        ),
                       `MinWidth( 30,
                       `SelectionBox( `id(`mods), _("Modules added to Rescue System:"), modules ) )
                       ),
                      `Label(_("Modules are sorted in the order they were loaded.")),
                      `ButtonBox(
                       `PushButton(`id(`ok    ), _( "&OK"     ) ),
                       `PushButton(`id(`cancel), _( "&Cancel" ) )
                      ),
                      `VSpacing(1)
                     ),
                    `HSpacing(1)
                    )
                   )
                  );

    symbol ret=nil;
    do
    {
        if ( ret == `delmod )
        {
             string delelem = (string)UI::QueryWidget( `id(`mods), `CurrentItem);
             modules = filter (string elem, modules, { return (elem != delelem ); });
             UI::ChangeWidget( `id(`mods), `Items, modules);
        }
        if ( ret == `addmod )
        {
             string addelem = (string)UI::QueryWidget( `id(`availablemods), `Value);
             if ( ! contains(modules,addelem) )
             {
                  modules = add(modules, addelem);
                  UI::ChangeWidget( `id(`mods), `Items, modules);
             }
             UI::ChangeWidget( `id(`mods), `Value, addelem );

        }
        if ( ret == `up || ret == `down )
        {
             string mod = (string)UI::QueryWidget( `id(`mods), `Value);
             integer pos=0;
             foreach (string tmpmod, modules, { if ( modules[pos]:"" == mod ) break; pos = pos +1; });

             if (pos > 0 && ret == `up)
             {
                modules[pos] = modules[pos-1]:"";
                modules[pos-1] = mod;
             }

             if (pos < size(modules)-1 && ret == `down)
             {
                modules[pos] = modules[pos+1]:"";
                modules[pos+1] = mod;
             }


             UI::ChangeWidget( `id(`mods), `Items, modules);
             UI::ChangeWidget( `id(`mods), `Value, mod );


        }

        ret = (symbol) UI::UserInput();

    }
    while (ret != `ok && ret != `cancel );

    UI::CloseDialog();

    if ( ret == `cancel )
            return modules_sav;

    return modules;
}



/**
 * Dialog to run rear
 */
symbol RearRunDialog () {

    UI::OpenDialog(`opt(`decorated),
    `HBox(`HSpacing(1.5), `VSpacing(18),
    `VBox(
        `HSpacing(80),
        `VSpacing(0.5),
        `LogView (`id (`log), "Rear output:", 8, 0),
        `VSpacing(0.5),
        `ReplacePoint (`id (`rp), (`Label(_("Preparing for Rear Execution.")))),
        `VSpacing(0.5),
        `PushButton (`id(`close), Label::CloseButton ()),
        `VSpacing(0.5)),
    `HSpacing(1.5)
    ));

    UI::ChangeWidget (`id(`close), `Enabled, false);

    if (!Package::Install ("rear"))
    {
        Report::Error (Message::CannotContinueWithoutPackagesInstalled ());
        UI::CloseDialog();
        return `close;
    }


    integer id = (integer) SCR::Execute (.process.start_shell, "/usr/sbin/rear mkbackup");
    UI::ReplaceWidget (`id (`rp), `Label ( _("Running rear...")));

    symbol ret = nil;
    do
    {
        ret = (symbol) UI::PollInput();

        if (SCR::Read(.process.running, id) != true)
        {
            string buf     = (string) SCR::Read (.process.read, id);
            string err_buf = (string) SCR::Read (.process.read_stderr, id);
            if (buf != nil && buf != "")
                UI::ChangeWidget (`id(`log), `LastLine, buf + "\n");
            if (err_buf != nil && err_buf != "")
                UI::ChangeWidget (`id(`log), `LastLine, err_buf + "\n");

            integer status  = (integer) SCR::Read (.process.status, id);
            if (status != 0)
            {
                 UI::ReplaceWidget (`id (`rp), `Label ( sformat( _("Execution failed with return value %1."), status )));
            }
            else
            {
                 UI::ReplaceWidget (`id (`rp), `Label ( _("Finished. You are strongly advised to test the created backup.")));
            }
            UI::ChangeWidget (`id(`close), `Enabled, true);
            ret = (symbol) UI::UserInput();
        }
        else
        {
             string line = (string)SCR::Read (.process.read_line, id);
             if (line != nil && line != "")
                 UI::ChangeWidget (`id(`log), `LastLine, line + "\n");
             string err = (string)SCR::Read (.process.read_line_stderr, id);
             if (err!= nil && err != "")
                 UI::ChangeWidget (`id(`log), `LastLine, err + "\n");
        }

        sleep (100);
    } while (ret != `close ); 

    UI::CloseDialog();
    return ret;
}





/**
 * Dialog for setup up Rear
 */
symbol RearConfigDialog () {

    // For translators: Caption of the dialog
    string caption = _("Rear Configuration");

    // help text for Rear 
    string help = _("<p>Configure Rear Relax and Recover (<b>ReaR</b>) backup for your computer.</p>") +
    _("<p>Decide how to start your <b>Recovery System</b>. Choose USB if you want to boot from an USB stick, or ISO for CD-ROM respectively.</p>")+

    _("<p>Choose where the <b>Backup</b> should be stored. Select NFS if you have to use a server that offers Network File System. Please specify the location as follows: <tt>nfs://hostname/directory</tt>. You can also choose USB to store your backup on an USB stick or USB disk.</p>")+

    _("<p>If no USB devices are shown, attach an USB stick or an USB disk and click <b>Rescan USB Devices</b>.</p>") +

    _("<p>Select <b>Keep old backup</b> if you don't want the previous backup copy to be overwritten.</p>") +

    _("<p>The <b>Advanced</b> menu offers to add <b>additional directories to the backup</b> and <b>additional kernel modules to the rescue system</b>. That's only useful if your backup doesn't contain all the needed directories or the rescue system doesn't boot due to missing kernel modules.</p>") +

    _("<p>The <b>Save and run rear now</b> button runs rear and shows rear's output. <strong>Make sure to test if the created backup works as expected on your system!</strong></p>") +

    _("<p><b>OK</b> saves the configuration and quits while <b>Cancel</b> closes the configuration dialog without saving.<p>");


    // get varibales from config
    list <string> netfs_url = [ Rear::netfs_url ];
    boolean netfs_keep_old_backup = Rear::netfs_keep_old_backup;
    list<string> modules_load = Rear::modules_load;
    list<string> backup_prog_include = Rear::backup_prog_include;
    string output = Rear::output;

    // set available options
    list<string> nfslocation = ["nfs://hostname/directory"];
    list backup_type = ["NFS", "USB"];
    list<string> outputlist = ["ISO", "USB"];

    // prepare advanced menu
    list<term> expertMenu = [ `item(`id(`additionalDirs), _("Additional Directories in Backup" )) ,
                              `item(`id(`additionalModules), _("Additional Kernel Modules in Rescue System" )) ];

    // prepare main dialog
    term con = `HBox (`HSpacing (3), `VBox (
        `VSpacing (),
	`Frame (_("Recovery System"), `HBox (`HSpacing (),
	    `VBox (
		`VSpacing (0.5),
		`ComboBox (`id(`output), `opt(`notify, `hstretch), _("&Boot Media"), outputlist),
		`VSpacing (0.5)
	    ), `HSpacing ()
	)),
	`VSpacing (1.5),
	`Frame (_("Backup"), `HBox (`HSpacing (),
	    `VBox (
		`VSpacing (0.5),
		`ComboBox (`id(`backup_type), `opt(`notify, `hstretch), _("&Backup Media"), backup_type),
		`VSpacing (0.5),
                `ReplacePoint(`id(`rp), `ComboBox (`id(`netfs_url), `opt(`notify, `hstretch, `editable), _("&Location"), netfs_url)),
		`VSpacing (0.5),
                `HBox(
		    `Left(`CheckBox (`id(`netfs_keep_old_backup), `opt(`notify), _("&Keep old backup"), netfs_keep_old_backup)),
                    `PushButton(`id(`scanusb), _( "Rescan USB Devices") )
                ),
		`VSpacing (0.5)
	    ), `HSpacing ()
	)),
	`VSpacing (0.5),
        `Right( `MenuButton( _("Advanced"), expertMenu )),
	`VSpacing (0.5),
        `PushButton(`id(`runrear), _( "Save and run rear now") ),
	`VStretch ()
    ), `HSpacing(3));


    Wizard::SetContents (caption, con, help, true, true);


    /* If config file was manually edited and config options are unknown we show a warning */
    boolean config_conflicts = false;
    string conflict_message = "";


    /* set settings according to options read from config file. */
    if ( Rear::backup != "NETFS" && Rear::backup !=  "" )
    {
        conflict_message = conflict_message + _("BACKUP is set to an unknown value.\n");
        config_conflicts = true;
    }

    /* choose selected option or fallback to "ISO" if nothing is set */
    if (contains(outputlist, output))
        UI::ChangeWidget (`id(`output), `Value, output);
    else if (output == "")
        UI::ChangeWidget (`id(`output), `Value, "ISO");
    else
    {
        conflict_message = conflict_message + _("OUTPUT is set to an unknown value.\n");
        config_conflicts = true;
    }

    string type = toupper(substring(Rear::netfs_url,0,3));
    if (contains(add(backup_type,""), type))
    {
        UI::ChangeWidget (`id(`backup_type), `Value, type);
        if ( type == "NFS" )
        {
           if ( ! contains (nfslocation, Rear::netfs_url) )
              nfslocation = prepend (nfslocation, Rear::netfs_url);
           UI::ChangeWidget (`id(`netfs_url), `Items, nfslocation );
        }
    }
    else
    {
        conflict_message = conflict_message + _("NETFS_URL is set to an unknown value or in wrong format.\n");
        config_conflicts = true;
    }


    if (config_conflicts &&
        ! Popup::ContinueCancel ( _("Your rear configuration file contains options this YaST2 module cannot configure.\n" )  + conflict_message +
                                  _("Do you want to continue and overwrite these settings?" )))
        return `abort;


    // this flag ensures that the combox is correctly 
    // refilled when the USB/NFS combobox is changed
    boolean rebuild_combobox_flag = false;

    symbol ret = nil;
    do
    {
        if ( UI::QueryWidget(`id(`backup_type), `Value ) == "USB" && rebuild_combobox_flag==false)
        {
           UI::ReplaceWidget(`id(`rp), `ComboBox (`id(`netfs_url), `opt(`notify, `hstretch), _("&Location"), UsbPartitions()));
           rebuild_combobox_flag=true;
        }

        if ( (string) UI::QueryWidget(`id(`backup_type), `Value ) == "NFS" && rebuild_combobox_flag==true )
        {
           UI::ReplaceWidget(`id(`rp), `ComboBox (`id(`netfs_url), `opt(`notify, `hstretch, `editable), _("&Location"), nfslocation));
           rebuild_combobox_flag=false;
        }

        // open run rear dialg, if usb boot medium is selected show a warning
        if ( ret == `runrear)
        {
	   if ( "USB" != (string) UI::QueryWidget(`id(`output), `Value ) || 
                Popup::ContinueCancel (_("Your USB medium will be overwritten. Do you want to continue?" )))
           {
               SaveConfig(modules_load, backup_prog_include);
	       RearRunDialog();
           }
        }


        if (ret == `scanusb )
        {
           if ( UI::QueryWidget(`id(`backup_type), `Value ) == "USB" )
               UI::ChangeWidget (`id(`netfs_url), `Items, UsbPartitions() );
        }

        // handle advanced menu
        if ( ret == `additionalModules)
            modules_load = KernelModulesDialog(modules_load);

        if ( ret == `additionalDirs)
            backup_prog_include = DirectoriesDialog(backup_prog_include);


	ret = (symbol) UI::UserInput ();

    } while (!contains ([`back, `abort, `cancel, `next, `ok], ret));

    if (ret == `next || ret == `ok)
        SaveConfig(modules_load, backup_prog_include);

    return ret;
}


/**
 * The whole sequence
 */
symbol RearSequence () {

    Wizard::OpenOKDialog ();
    Wizard::SetDesktopTitle( _("Rear Configuration") );
    Wizard::SetDesktopIcon("backup");

    if (! Confirm::MustBeRoot () )
    {
        UI::CloseDialog ();
        return `abort;
    }

    Storage::InitLibstorage(true); // true: read-only

    /* Rear read dialog caption */
    string caption      = _("Reading Rear Configuration");
    integer steps       = 2;

    Progress::New (caption, " ", steps, [
            _("Analyzing system"),
            _("Reading rear settings"),
        ], [
            _("Analyzing system..."),
            _("Reading rear settings..."),
            _("Finished")
        ],
        ""
    );

    Progress::NextStage();

    list <string> system_check_messages = RearSystemCheck::SystemCheck();

    if ( system_check_messages != [])
    { 
        y2warning ("This system is not supported by rear!");
        if ( UnsupportedDialog(system_check_messages) == `ok )
        {
            y2milestone ("It was the user's decision to use rear although this system is not supported.");
        }
        else
        {
            y2milestone ("User decided to quit yast2-rear because this system is not suported.");
            return `abort;
        }
    }

    Progress::NextStage();

    Rear::Read ();

    Progress::NextStage();

    symbol ret = RearConfigDialog ();
    if ( ret == `next || ret == `ok )
        Rear::Write ();

    UI::CloseDialog ();
    return ret;
}

}
